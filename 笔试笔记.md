
## 数据基本概念

1. 数据结构中，从逻辑上可以把数据结构分成 **线性结构** 和 **非线性结构**
2. 数据的**逻辑结构**与数据元素本身的**形式、内容、相对位置、个数无关**
3. 同一逻辑结构中的所有数据元素具有相同特性，意味着不仅数据元素所包含的**数据项个数**要相同，对应**数据项的类型**也要一致
4. **数据结构**是带有结构的**数据元素集合**，**数据元素**是数据的**基本单位**，由多个数据项组成，而**数据项**是数据的**最小单位**
5. **有序表**：数据元素按某种顺序排列的逻辑结构，强调数据之间的顺序关系，与数据的存储结构无关（**有关的是顺序队列、链表、链栈**）
6. 

## 线性表
1. 元素的平均移动个数= `n/2`
2. **链接储存**的存储结构所占存储空间分为**两**部分，一部分存放**结点值**，一部分存放**表示结点间关系的指针**
3. 线性表若采用**链式存储结构**，要求内存中可用存储单元的地址**连续或不连续**都可以
4. 线性表L在**需不断对L进行删除插入**的请改下适用于使用**链式结构**实现
5. **单链表**的存储密度**小于1**
6. 将两个各有n各元素的有序表归并成一个有序表，最少的比较次数是**n**次
7. 线性表L是由n（n≥0）个数据元素组成的有限序列。其元素是**按照顺序排列的**，每个元素（除第一个和最后一个外）有且仅有一个直接前驱和一个直接后继。
8. 线性表**可以为空**（即n=0），此时表中没有任何元素。
9. 线性表的元素的排列顺序是逻辑上的，并**不要求元素的值必须有序**
10. 若指定有n个元素的向量，建立一个有序单链表的时间复杂性的量级是`O(n^2)` (如果先对向量排序，则是`O(nlogn)`）
11. 求表⻓、定位这两种运算在采⽤顺序存储结构时实现的效率不⽐采⽤链式存储结构时实现的效率低
12. **顺序存储**的线性表**可以随机存取**
13. 由于**顺序存储要求连续的存储区域**，所以在存储管理上不够灵活
14. 线性表的链式存储结构不优于顺序存储结构
15. 如何应对指针修改题：自己画图，要保证根据顺序接上
16. 对线性表进⾏⼆分法查找，其前提条件是线性表**以顺序⽅式存储，并且按关键码值排好序**
17. **链表属于一种存储结构**（线性表，栈，队列、二叉树、字符串不是）
18. 若某线性表常⽤操作是**在表尾插⼊或删除元素，则时间开销最⼩的存储⽅式是顺序表**
19. 基于**单链表的操作，相较于顺序表实现，带来更⾼时间复杂度**的操作是**输出第i个元素**
20. 使⽤**线性探测法处理散列表碰撞**问题，若表中**仍有空槽（空单元），插⼊操作⼀定成功**
21. 从**链表中删除某个指定值的结点的时间复杂度是 O(n)**，主要由查找操作决定。删除操作本身是常数时间 O(1)
22. **双散列法**是一种解决哈希冲突的方法。当发生冲突时，使用第二个哈希函数计算一个步长，然后按照以下公式计算下一个探测位置：`h ( k e y , i ) = ( h_{1} ( k e y ) + i × h_{2} ( k e y ) ) \%表大小`,其中i是冲突次数（从0开始）。
23. 删除⻓度为 n 的顺序表的第 i 个数据元素需要移动表中的 n-i个数据元素


## 栈和队列
1. **栈**（Stack）是一种常用的数据结构，遵循**后进先出**（LIFO, Last In First Out）的原则
2. 数组Q [n]用来表示一个循环队列，f为当前队列头元素的前一位置，r为队尾元素的位置，假定队列中元素的个数小于n，计算队列中元素个数的公式为`(n+r-f)\%n`
3. 栈在**递归调用、 函数调用、表达式求值**中有所应用。
4. **队列**是一种 **先进先出**（FIFO, First In First Out） 的线性数据结构
5. ⽤链接⽅式存储的队列，在进⾏删除运算时，**头、尾指针可能都要修改**
6. 循环队列存储在数组A[0..m]中，则⼊队时的操作为`rear=(rear+1)%(m+1)`
7. 最⼤容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是`rear==front`，队满的条件是`(rear+1)%n == front`
8. 栈和队列共同点是**只允许在端点处插入和删除元素**
9. ⼀个递归算法必须包括**终止条件和递归部分**
10. 给定一个N个相异元素构成的有序数列，设计一个递归算法实现数列的**二分查找**，考察递归过程中栈的使用情况，请问这样一个**递归调用栈的最小容量应为 \lceil \log_{2}(N + 1)**

## 串和数组
1. 串是一种特殊的线性表，是**字符的有限序列**，体现在**数据元素是一个字符**，**模式匹配**是串的一种重要运算
2. 串既可以采用顺序存储，也可以采用链式存储
3. 串的**长度指的是串中所含字符的个数**
4. A[N，N]是对称矩阵，将下⾯三⻆（包括对⻆线）以⾏序存储到⼀维数组T[N(N+1)/2]中，则对任⼀上三⻆元素a[i][j]对应T[k]的下标k是`j*(j-1)/2 + i`
5. 设⼆维数组A[1.. m，1.. n]（即m⾏n列）按⾏存储在数组B[1.. m*n]中，则⼆维数组元素A[i,j]在⼀维数组B中的下标为 `(i-1)*n + j`
6. 

## 树和二叉树
1. 把⼀棵树转换为⼆叉树后，这棵⼆叉树的形态是唯⼀的
2. 给定 n 个结点可以构造 `C_n = (2n)! / (n+1)!n! ` 个二叉树 **【重要！！】**
3. 完全⼆叉树每⼀层的节点数为 `2^0,2^1,2^2,...,2^(h-1),2^h`
4. 完全二叉树的叶子节点个数为 `[n/2]取上限` **【重要！！】**
5. 二叉树n个结点高度最小为完全二叉树：` 2^h <= n < 2^(h+1) `  ,最高高度`h=n`
6. 满二叉树高度与结点关系 ` n=2^(h+1) -1 `
7. 满 m 叉树是指除最后一层外，每一层上的所有结点都有 m个子结点；每一层（包括最后一层 ）的结点都完全填满，**深度为h的满m叉树第k层有`m^(k-1) `**
8. 对⼆叉树的结点从1开始进⾏连续编号，要求每个结点的编号⼤于其左、右孩⼦的编号，同⼀结点的左右孩⼦中，其左孩⼦的编号⼩于其右孩⼦的编号，可采⽤**后序**遍历实现编号
9. ⽗节点只有在它的所有⼦节点都编号之后才能获得⼀个⽐它们⼤的编号（后序）
10. **后序遍历顺序：左 → 右 → 根**
11. **前序遍历顺序：根 → 左 → 右**
12. **中序遍历顺序： 左 → 根 → 右**
13. **层次遍历：按层从上到下、从左到右**
14. 树的存储形式：**双亲（parent）表示法、孩⼦链表表示法 、孩⼦兄弟表示法**
15. **⾮空树的先序和后序相反**，即“根左右”与“左右根”顺序相反，因此，树中所有⾮叶结点的度均为1，**即⼆叉树仅有个叶结点**
16. 设F是⼀个森林，B是由F变换得的⼆叉树。**若F中有n个⾮终端结点，则B中右指针域为空的结点有`n+1`个**
17. **森林转换为二叉树**的常用方法是 “**左孩子右兄弟**”表示法（也称为孩子兄弟表示法）。**森林中第一棵树的根作为二叉树的根**；**第一棵树的子树（孩子）转换为二叉树的左子树**；**森林中剩余的树（兄弟）转换为二叉树的右子树**
18. 按照**前序、中序、后序**⽅式周游⼀棵⼆叉树，分别得到不同的结点周游序列，然⽽**三种不同的周游序列中，叶⼦结点都将以相同的顺序**出现
19. 通过树的周游可以求得树的⾼度，若采取**深度优先**遍历⽅式设计**求解树⾼度**问题的算法，算法**空间复杂度⼤ O 表示为 O（树的⾼度)**
20. **树可以等价转化⼆叉树**，树的**先序遍历序列与其相应的⼆叉树的前序遍历序列相同**
21. 设总节点数为N，度数为0、1、2、...n的节点数分别为n_{0} 、n_{1} 、n_{2}...n_{n} ，则：**N = n_{0} + n_{1} + n_{2}+...n_{n}	（总节点数公式）**
22. 二叉树中，每个度数为d的节点贡献d条边，且总边数等于节点数减1（除根节点外，每个节点有一条父边），**即：n_{1} + 2 n_{2} +3 n_{3} +...+ n n_{n}= N - 1	（边数公式）**
23. **BST 树是⼆叉树**，对于所有的⼦树⽽⾔，**其左⼦树上所有关键值都⼩于根，右⼦树上的所有关键值都⼤于根**
24. 完全二叉树通常用数组表示，其中： 对于索引为i的结点：**左子结点索引:2i+1** **右子结点索引：2i+2**；**父结点索引：\lfloor ( i - 1 ) / 2 \rfloor**，**最后一个非叶结点的索引：	\lfloor n / 2 \rfloor - 1**
25. 给定一个二叉树，若**前序遍历序列与中序遍历序列相同**，则二叉树是 **只有根结点的二叉树或非叶子结点只有右子树**的二叉树
26. 如果X和Y分属不交的⼦树，那么他们在先根和后根周游中的前后关系是⼀致的。出现反转的话，他们只能是祖先/后裔关系
27. 设叶节点x个，分支节点n-X个，**树的性质有节点数等于所有节点度数和+ 1** , (n - x)^{ * }k + 1 = n , x = n - (n -1）/k
28. 在任意一棵二叉树中，**所有叶节点在前序、中序和后序遍历序列中的相对次序不发生改变。**
29. 有n 个节点的⼆叉排序树有多种，其中**树⾼最⼩的⼆叉排序树是搜索效率最好**

## 图
1. 无向图：**度数之和 = 2× 边数**
2. 有向图：**入度之和 = 出度之和**
3.  具有n个顶点的有向图最多有`n(n-1)`条边
4.  n个顶点的连通图⽤邻接矩阵表示时，该矩阵⾄少有`2(n-1)`个⾮零元素
5.  完全图（连通图）最大边数为 `n(n-1)/2`
6.  已知非连通无向图有n个边，则最少顶点数为完全图最大边数所需顶点m+1
7.  若从⽆向图的任意⼀个顶点出发进⾏⼀次深度优先搜索可以访问图中所有的顶点，则该图⼀定是连通图
8.  最小生成树生成算法：**Prim**(贪心算法）
9.  ⽤**邻接表**表示图进⾏**⼴度优先**遍历时，通常借助**队列**来实现算法
10. ⽤**邻接表**表示图进⾏**深度优先**遍历时，通常借助**栈**来实现算法
11. **深度优先**遍历类似于**⼆叉树的先序遍历**
12. **⼴度优先**遍历类似于**⼆叉树的层次遍历**
13. 图的BFS⽣成树的树⾼⽐DFS⽣成树的树⾼**小或相等**
14. 判断**有无环：拓扑排序**
15.**n个顶点m条边的⽆向图**，采⽤**邻接表储存，储存该图的空间复杂度为O (m+n)**
16. **n个顶点m条边的⽆向图**，若为**稠密图，更倾向于采⽤邻接矩阵存储**
17. **n个顶点m条边的⽆向图**，采⽤**邻接表储存**，**删除⼀个顶点的最坏**情况的时间复杂度为**O (n+m）**
18. **n个顶点m条边的⽆向图**，若为**稀疏图**，**深度**优先周游的**时间复杂度高于⼴度**优先周游的时间复杂度
19. 若**连通⽆向图的边的权值互不相同**，其**最⼩⽣成树只有⼀个**
20. 设⼀棵m叉树中有 N1个度数为1的结点（度数表示⼦结点个数）， N2个度数为2的结点，……，Nm 个度数为m的结点，则该m叉树中共有 `1+sum(m,i=2) (i-1)N_i `个终端结点
21. 一个⽆向图，如果**边的数量m >=结点个数n，那么该图定存在回路**
22. 如果⼀个**连通⽆向图 G 中所有边的权值均不同**，则 G **具有唯⼀的最⼩⽣成树**
23. **Dijkstra 算法的局限性**是⽆法正确**求解带有负权值边的图**的最短路径
24. **无向图邻接表中边表的最大结点数为n(n-1)**
25. 每个顶点的入度和出度分别表示其作为终点和起点的边数，单个顶点的**度数（入度 + 出度）最大为 2(n−1)**（完全有向图中，每个顶点与其他 n-1 个顶点双向连边）。
26. **所有顶点的入度和出度之和等于有向图边数的 2 倍**（每条有向边贡献 1 个出度和 1 个入度）。
27. 对任意⼀个**连通的、⽆环的⽆向图，从图中移除任何⼀条边得到的图均不连通**
28. 

## 查找
1. 对n个元素的表做顺序查找时，若查找每个元素的概率相同，则平均查找⻓度为 `(n+1)/2 `
2. 当在⼀个有序的顺序表上查找⼀个数据时，既可⽤折半查找，也可⽤顺序查找，**但前者⽐后者的查找速度大部分情况下要快**
3. 折半查找是种⾼效的查找算法，适⽤于有序表，其基本思想是：每次将中间位置的关键字与⽬标值⽐较，若相等则查找成功，若⽬标较⼩，则在左半部分继续查找，若⽬标较⼤，则在右半部分继续查找重复这个过程，直到找到或查找范围为空（查找失败)
4. 二叉排序树的构造规则：**若插入结点值小于根结点，插入左子树；大于根结点，插入右子树，逐层构建**
5. LL 型：A的左孩子的左子树导致不平衡（左孩子平衡因子正 ）
6. LR 型：A的左孩子的右子树导致不平衡（左孩子平衡因子负 ）
7. RL 型：A的右孩子的左子树导致不平衡（右孩子平衡因子正 ）
8. RR 型：A的右孩子的右子树导致不平衡（右孩子平衡因子负 ）
9. m阶B-树**根结点⾄多有 m棵⼦树**，**所有叶⼦结点都在同⼀层次**，⾮叶结点⾄少有m/2 (m为偶数)或m/2+1（m为奇数）棵⼦树 ，根节点中的数据不一定有序
10. 哈希函数的目标是在满足需求的前提下，尽可能简单、高效
11. 哈希表的平均查找长度（ASL ）主要与哈希函数的优劣（哈希值分布是否均匀 ）、冲突处理方法（开放定址法、链地址法等 ）相关，与 “记录总数” 无直接关联
12. 哈希查找中，采⽤**链地址法**处理冲突时，**若插⼊规定总是在链⾸，则插⼊任⼀个元素的时间是相同的，不会引起⼆次聚集现象，适合表⻓不确定的情况**
13. **哈希表二次探测法**的探查公式为：`H_i=(H(key)±i^2)%m`
14. 

## 排序
1. 从未排序序列中**依次取出元素与已排序序列中的元素进⾏⽐较**，将其放⼊已排序序列的正确位置上的⽅法，这种排序⽅法称为**插入排序**
2. 从未排序序列中**挑选元素，并将其依次放⼊已排序序列**（初始时为空）的⼀端的⽅法，称为**选择排序**
3. 重复遍历数组，**依次比较相邻元素**，若逆序则交换，直到无交换发生，称为**冒泡排序**
4. 将**数组递归地分成两半**，直到子数组长度为1；将两个已排序的子数组合并为一个有序数组，称为**归并排序**（内存最大，但是最稳定）
5. 对n个不同的关键字由⼩到⼤进⾏**冒泡排序**，在**从⼤到⼩排列好的**情况下⽐较的**次数最多**
6. 对n个不同的排序码进⾏**冒泡排序**，在**元素⽆序的情况下⽐较的次数最多**为`n(n-1)/2`
7. **快速排序**（Quick Sort）是一种分治算法，通常选取数组的第一个、最后一个或随机元素作为选择基准；**将数组分为两部分，左边小于基准，右边大于基准**，对左右子数组重复上述过程
8. **快速排序**在被排序数据**完全无序情况下最佳**(O(nlogn))，在数据已**基本有序最差**(O(n^2))
9. **堆是一种完全二叉树**，属于**选择排序**，**大顶堆**（Max-Heap）：每个节点的值 ≥ 其子节点的值。**小顶堆**（Min-Heap）：每个节点的值 ≤ 其子节点的值。
10. 堆排序：从**下往上最后一个⾮叶节点开始**下沉调整
11. **希尔排序**（Shell Sort）是一种**插入排序**的改进算法，通过将待排序序列分割成若干个子序列，对每个子序列进行插入排序，**不能保证每趟至少能将一个元素放到最终位置**
12. 在插⼊排序算法中，如果待排序的序列已经**是有序的**，则插⼊**排序算法的时间复杂度为 O(n)**
13. 在**⼆分查找算法**中，每次⽐较后都将搜索范围缩⼩⼀半，若要在⻓度为n的数组中查找⼀个元素，**最坏情况下需要⽐较 [log(n)]+1(向下取整）**
14. **分治算法:O(nlogn)**
15. 具有**稳定排序特性的是冒泡排序**（Bubble Sort）
16. 构建⼀个**含 N 个结点的（⼆叉）最⼩值堆**，时间效率最优情况下的时间复杂度⼤ O 表示为**O(N)**
17. 如果输⼊序列是**已经正序**，在(改进)冒泡排序、直接插⼊排序和直接选择排序算算法中，**直接选择排序算法最慢结束**
18. **Kruskal 算法是按权值从小到大选边**，每次选最小的边，并且不形成环，直到选够 n-1 条边，**每次选边后合并连通分量**，直到所有顶点连通。
19. **快速排序和选择排序**都属于不同的排序算法，但它们的**最坏情况下的时间复杂度都是O(n^2)**
20. 分治和动态规划都是将问题分解为⼦问题，然后合并⼦问题的解得到原问题的解。但是不同的是，分治法分解出的⼦问题是不重叠的，因此分**治法解决的问题不拥有重叠⼦问题，⽽动态规划解决的问题拥有重叠⼦问题**
21. 考察某个具体问题是否**适合应⽤动态规划算法，必须判定它是否具有最优⼦结构性质**
22. 目标串⻓是 n，模式串⻓是 m，**朴素模式匹配算法最多比较次数 O（mn）**
23. **奇偶交换排序是稳定的排序**。稳定排序是指如果两个元素相等，在排序后它们的相对顺序仍然保持不变
24. 在**n^{2}个数中找到最小值，至少需要n^{2} - 1次比较**。


使用最大顶堆对序列 [1, 3, 43, 8, 7] 进行排序的步骤如下：

构建最大顶堆：

初始序列：1, 3, 43, 8, 7

调整后堆：43, 8, 1, 3, 7

堆排序：

依次交换堆顶与末尾元素并调整堆：

43 ↔ 7 → 调整 → 8, 7, 1, 3 | 43

8 ↔ 3 → 调整 → 7, 3, 1 | 8, 43

7 ↔ 1 → 调整 → 3, 1 | 7, 8, 43

3 ↔ 1 → 1 | 3, 7, 8, 43

排序结果（升序）：1, 3, 7, 8, 43
