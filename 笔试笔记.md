
## 数据基本概念

1. 数据结构中，从逻辑上可以把数据结构分成 **线性结构** 和 **非线性结构**
2. 数据的**逻辑结构**与数据元素本身的**形式、内容、相对位置、个数无关**
3. 同一逻辑结构中的所有数据元素具有相同特性，意味着不仅数据元素所包含的**数据项个数**要相同，对应**数据项的类型**也要一致
4. **数据结构**是带有结构的**数据元素集合**，**数据元素**是数据的**基本单位**，由多个数据项组成，而**数据项**是数据的**最小单位**
5. **有序表**：数据元素按某种顺序排列的逻辑结构，强调数据之间的顺序关系，与数据的存储结构无关（**有关的是顺序队列、链表、链栈**）
6. 

## 线性表
1. 元素的平均移动个数= `n/2`
2. **链接储存**的存储结构所占存储空间分为**两**部分，一部分存放**结点值**，一部分存放**表示结点间关系的指针**
3. 线性表若采用**链式存储结构**，要求内存中可用存储单元的地址**连续或不连续**都可以
4. 线性表L在**需不断对L进行删除插入**的请改下适用于使用**链式结构**实现
5. **单链表**的存储密度**小于1**
6. 将两个各有n各元素的有序表归并成一个有序表，最少的比较次数是**n**次
7. 线性表L是由n（n≥0）个数据元素组成的有限序列。其元素是**按照顺序排列的**，每个元素（除第一个和最后一个外）有且仅有一个直接前驱和一个直接后继。
8. 线性表**可以为空**（即n=0），此时表中没有任何元素。
9. 线性表的元素的排列顺序是逻辑上的，并**不要求元素的值必须有序**
10. 若指定有n个元素的向量，建立一个有序单链表的时间复杂性的量级是`O(n^2)` (如果先对向量排序，则是`O(nlogn)`）
11. 求表⻓、定位这两种运算在采⽤顺序存储结构时实现的效率不⽐采⽤链式存储结构时实现的效率低
12. **顺序存储**的线性表**可以随机存取**
13. 由于**顺序存储要求连续的存储区域**，所以在存储管理上不够灵活
14. 线性表的链式存储结构不优于顺序存储结构
15. 如何应对指针修改题：自己画图，要保证根据顺序接上



## 栈和队列
1. **栈**（Stack）是一种常用的数据结构，遵循**后进先出**（LIFO, Last In First Out）的原则
2. 数组Q [n]用来表示一个循环队列，f为当前队列头元素的前一位置，r为队尾元素的位置，假定队列中元素的个数小于n，计算队列中元素个数的公式为`(n+r-f)\%n`
3. 栈在**递归调用、 函数调用、表达式求值**中有所应用。
4. **队列**是一种 **先进先出**（FIFO, First In First Out） 的线性数据结构
5. ⽤链接⽅式存储的队列，在进⾏删除运算时，**头、尾指针可能都要修改**
6. 循环队列存储在数组A[0..m]中，则⼊队时的操作为`rear=(rear+1)%(m+1)`
7. 最⼤容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是`rear==front`，队满的条件是`(rear+1)%n == front`
8. 栈和队列共同点是**只允许在端点处插入和删除元素**
9. ⼀个递归算法必须包括**终止条件和递归部分**

## 串和数组
1. 串是一种特殊的线性表，是**字符的有限序列**，体现在**数据元素是一个字符**，**模式匹配**是串的一种重要运算
2. 串既可以采用顺序存储，也可以采用链式存储
3. 串的**长度指的是串中所含字符的个数**
4. A[N，N]是对称矩阵，将下⾯三⻆（包括对⻆线）以⾏序存储到⼀维数组T[N(N+1)/2]中，则对任⼀上三⻆元素a[i][j]对应T[k]的下标k是`j*(j-1)/2 + i`
5. 设⼆维数组A[1.. m，1.. n]（即m⾏n列）按⾏存储在数组B[1.. m*n]中，则⼆维数组元素A[i,j]在⼀维数组B中的下标为 `(i-1)*n + j`
6. 

## 树和二叉树
1. 把⼀棵树转换为⼆叉树后，这棵⼆叉树的形态是唯⼀的
2. 给定 n 个结点可以构造 `C_n = (2n)! / (n+1)!n! ` 个二叉树 **【重要！！】**
3. 完全⼆叉树每⼀层的节点数为 `2^0,2^1,2^2,...,2^(h-1),2^h`
4. 完全二叉树的叶子节点个数为 `[n/2]取上限` **【重要！！】**
5. 二叉树n个结点高度最小为完全二叉树：` 2^h <= n < 2^(h+1) `  ,最高高度`h=n`
6. 满二叉树高度与结点关系 ` n=2^(h+1) -1 `
7. 满 m 叉树是指除最后一层外，每一层上的所有结点都有 m个子结点；每一层（包括最后一层 ）的结点都完全填满，**深度为h的满m叉树第k层有`m^(k-1) `**
8. 对⼆叉树的结点从1开始进⾏连续编号，要求每个结点的编号⼤于其左、右孩⼦的编号，同⼀结点的左右孩⼦中，其左孩⼦的编号⼩于其右孩⼦的编号，可采⽤**（ 后序 ）**遍历实现编号
9. ⽗节点只有在它的所有⼦节点都编号之后才能获得⼀个⽐它们⼤的编号（后序）
10. **后序遍历顺序：左 → 右 → 根**
11. **前序遍历顺序：根 → 左 → 右**
12. **中序遍历顺序： 左 → 根 → 右**
13. **层次遍历：按层从上到下、从左到右**
14. 树的存储形式：**双亲（parent）表示法、孩⼦链表表示法 、孩⼦兄弟表示法**
15. **⾮空树的先序和后序相反**，即“根左右”与“左右根”顺序相反，因此，树中所有⾮叶结点的度均为1，**即⼆叉树仅有个叶结点**
16. 设F是⼀个森林，B是由F变换得的⼆叉树。**若F中有n个⾮终端结点，则B中右指针域为空的结点有`n+1`个**
17. 

## 图
1. 无向图：**度数之和 = 2× 边数**
2. 有向图：**入度之和 = 出度之和**
3.  具有n个顶点的有向图最多有`n(n-1)`条边
4.  n个顶点的连通图⽤邻接距阵表示时，该矩阵⾄少有`2(n-1)`个⾮零元素
5.  完全图（连通图）最大边数为 `n(n-1)/2`
6.  已知非连通无向图有n个边，则最少顶点数为完全图最大边数所需顶点m-1
7.  若从⽆向图的任意⼀个顶点出发进⾏⼀次深度优先搜索可以访问图中所有的顶点，则该图⼀定是连通图
8.  最小生成树生成算法：**Prim**
9.  ⽤**邻接表**表示图进⾏**⼴度优先**遍历时，通常借助**队列**来实现算法
10. ⽤**邻接表**表示图进⾏**深度优先**遍历时，通常借助**栈**来实现算法
11. **深度优先**遍历类似于**⼆叉树的先序遍历**
12. **⼴度优先**遍历类似于**⼆叉树的层次遍历**
13. 图的BFS⽣成树的树⾼⽐DFS⽣成树的树⾼**小或相等**
14. 判断**有无环：拓扑排序**
15. 

## 查找
1. 对n个元素的表做顺序查找时，若查找每个元素的概率相同，则平均查找⻓度为 `(n+1)/2 `
2. 当在⼀个有序的顺序表上查找⼀个数据时，既可⽤折半查找，也可⽤顺序查找，**但前者⽐后者的查找速度大部分情况下要快**
3. 折半查找是种⾼效的查找算法，适⽤于有序表，其基本思想是：每次将中间位置的关键字与⽬标值⽐较，若相等则查找成功，若⽬标较⼩，则在左半部分继续查找，若⽬标较⼤，则在右半部分继续查找重复这个过程，直到找到或查找范围为空（查找失败)
4. 二叉排序树的构造规则：**若插入结点值小于根结点，插入左子树；大于根结点，插入右子树，逐层构建**
5. LL 型：A的左孩子的左子树导致不平衡（左孩子平衡因子正 ）
6. LR 型：A的左孩子的右子树导致不平衡（左孩子平衡因子负 ）
7. RL 型：A的右孩子的左子树导致不平衡（右孩子平衡因子正 ）
8. RR 型：A的右孩子的右子树导致不平衡（右孩子平衡因子负 ）
9. m阶B-树**根结点⾄多有 m棵⼦树**，**所有叶⼦结点都在同⼀层次**，⾮叶结点⾄少有m/2 (m为偶数)或m/2+1（m为奇数）棵⼦树 ，根节点中的数据不一定有序
10. 哈希函数的目标是在满足需求的前提下，尽可能简单、高效
11. 哈希表的平均查找长度（ASL ）主要与哈希函数的优劣（哈希值分布是否均匀 ）、冲突处理方法（开放定址法、链地址法等 ）相关，与 “记录总数” 无直接关联
12. 哈希查找中，采⽤**链地址法**处理冲突时，**若插⼊规定总是在链⾸，则插⼊任⼀个元素的时间是相同的，不会引起⼆次聚集现象，适合表⻓不确定的情况**
13. **哈希表二次探测法**的探查公式为：H_i=(H(key)±i^2)%m
14. 

## 排序
1. 从未排序序列中**依次取出元素与已排序序列中的元素进⾏⽐较**，将其放⼊已排序序列的正确位置上的⽅法，这种排序⽅法称为**插入排序**
2. 从未排序序列中**挑选元素，并将其依次放⼊已排序序列**（初始时为空）的⼀端的⽅法，称为**选择排序**
3. 重复遍历数组，**依次比较相邻元素**，若逆序则交换，直到无交换发生，称为**冒泡排序**
4. 将**数组递归地分成两半**，直到子数组长度为1；将两个已排序的子数组合并为一个有序数组，称为**归并排序**（内存最大，但是最稳定）
5. 对n个不同的关键字由⼩到⼤进⾏**冒泡排序**，在**从⼤到⼩排列好的**情况下⽐较的**次数最多**
6. 对n个不同的排序码进⾏**冒泡排序**，在**元素⽆序的情况下⽐较的次数最多**为`n(n-1)/2`
7. **快速排序**（Quick Sort）是一种分治算法，通常选取数组的第一个、最后一个或随机元素作为选择基准；**将数组分为两部分，左边小于基准，右边大于基准**，对左右子数组重复上述过程
8. **快速排序**在被排序数据**完全无序情况下最佳**(O(nlogn))，在数据已**基本有序最差**(O(n^2))
9. **堆是一种完全二叉树**，属于**选择排序**，**大顶堆**（Max-Heap）：每个节点的值 ≥ 其子节点的值。**小顶堆**（Min-Heap）：每个节点的值 ≤ 其子节点的值。
10. 堆排序：从**下往上最后一个⾮叶节点开始**下沉调整
11. **希尔排序**（Shell Sort）是一种**插入排序**的改进算法，通过将待排序序列分割成若干个子序列，对每个子序列进行插入排序，**不能保证每趟至少能将一个元素放到最终位置**
12. 

